关于自增自减

for (int j = 0; j < time; j++)
            printf("打%d次.\n", j + 1);

两种使用方式:前缀\后缀
a++
++a

共同点:当自增自减只出现在表达式中 前后缀对结果相同
不同点:前后缀在复合表达式中的赋值操作优先级不同 
    前缀: 优先自增\减运算 并将结果赋值给左值
    后缀:表达式其他部分结果赋值给左值  最后做自增\减运算

注意:建议在条件对比表达式中使用前缀方式 
    顺序为:先自增\减值 最后对比  可以避免比较之后才递增，而不是先递增再比较。超出一次循环

递增\减操作符 下例中使用会 导致歧义
1.while (num < 21) {
    printf("%10d %10d\n", num, num*num++); 
    }
    **如果编译器先执行函数的最后一个参数呢?

2.ans = num/2 + 5*(1 + num++);
    **此时编译器也会根据效率选着执行不同的部分  编译器可能先计算第2项(5*(1+num++))，递增num，然后在num/2中使用num递增后的新 值。因此，无法保证编译器到底先计算哪一项。

3.n = 3;
 y = n++ + n++;
    **编译器可能执行顺序:
        1.n使用旧值3 两次  3+3 赋值给y  然后n递增两次 n=5
        2.n使用旧值3 一次  递增一次 3+4 赋值给y 最后再递增一次 n=5

总结规避歧义的规则:

如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或 递减运算符； 
如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减 运算符。

自增自减的本质是：

    ~将数据从内存读取到寄存器

    ~在寄存器中完成加1或减1操作

    ~将数据从寄存器写回内存

玩什么自增自减不能操作表达式?

        据上文本质:其实是对固定的内存地址内的值进行+1或-1。所以要能够自增自减首先就要满足有固定的内存地址，而对于表达式来说，最终表达式计算得到的结果如果不赋值给变量的话是没有固定内存地址记录这个值的。